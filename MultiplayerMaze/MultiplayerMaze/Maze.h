/*************************************************
Copyright:Bo Li
Author:
Date:2020-11-9
Description: A kind maze generated by using Prim Algorithm
**************************************************/
#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <list>
#include "Path.h"
#include "Player.h"

using namespace std;

enum Direction
{
	kNull,
	kNorth,
	kEast,
	kSouth,
	kWest,
};

struct Wall
{
	int y_;
	int x_;
	Direction dir_;
	Wall(int y = 0, int x = 0, Direction dir = Direction::kNull)
	{
		y_ = y;
		x_ = x;
		dir_ = dir;
	}
};

class Maze
{
private:

	int height_;
	int width_;

	int num_start_;
	vector<Point*> list_start_; //Is Finish List for cw2
	int num_exit_;
	vector<Point*> list_exit_; //Is Entry List for cw2

	char** array_;
	char** array_base_;

	vector<Wall> wall_list_; //use BST(set) instead of vector?

	Path* path_;
	vector<Player*> list_player_;
	int no_player_cur_;
	int count_player_finish;

	vector<int> list_turn_wait_;

	bool b_end_normal_;

	static const char kWall = 'X';
	static const char kStart = 'S';
	static const char kFinish = 'F';
	static const char kExit = 'E';
	static const char kEmpty = ' ';
	static const char kPath = 'o';
	static const char kPlayer = 'P';
	
	bool bPassable(const int y, const int x, const Direction dir) const;

	void AddWall(const int y_cur_, const int x_cur_);

	void UpdateArray();

	/*
	Description:    Determine whether a boundary wall is suitable as an exit
	Input:			y: y of the boundary wall
					x: x of the boundary wall
	Return:         return true if it is suitable
	*/
	bool bSuitableExit(const int y, const int x) const;

	void DrawPath(list<PathPoint*> list_path);

	void UpdateStartAndExit();

	void GeneratePlayer(list<PathPoint*> list_path);

	void Reset(int height = 0, int width = 0, int count_exit = 0);

	bool bDeadLock();

public:

	Maze(int height, int width, int count_exit) :height_(height), width_(width), num_exit_(count_exit), num_start_(1), array_(nullptr), array_base_(nullptr), no_player_cur_(0),count_player_finish(0),path_(nullptr)
	{
	}

	~Maze();

	void Generate();

	void Regenerate(int height, int width, int count_exit);

	void ReleaseMemory();

	void Draw();

	void SaveToFile(const string& name = "NewFile");

	void LoadFromFile(string name);

	void ResetToMazeBase();

	void GeneratePath(bool b_generate_player);

	bool MoveInTurns(bool b_how);

	bool bEndNormal() const;

	void AutoOperate();

	friend class Path;

	friend class Player;

};


